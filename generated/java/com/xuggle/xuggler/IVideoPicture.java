/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.xuggle.xuggler;
import com.xuggle.ferry.*;
/**
 * Represents one raw (undecoded) picture in a video stream, plus a timestamp<br>
 * for when to display that video picture relative to other items in a {IContainer}.<br>
 * <p><br>
 * All timestamps for this object are always in Microseconds.<br>
 * </p>
 */
public class IVideoPicture extends IMediaData {
  private transient long swigCPtr;

  protected IVideoPicture(long cPtr, boolean cMemoryOwn) {
    super(XugglerJNI.IVideoPicture_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected static long getCPtr(IVideoPicture obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        throw new UnsupportedOperationException("C++ destructor does not have public access");
      }
      swigCPtr = 0;
    }
    super.delete();
  }


  /**
   * info about this packet
   * @return information about this packet
   */
   
  @Override
  public String toString()
  {
    StringBuilder result = new StringBuilder();
    
    result.append(this.getClass().getName()+"@"+hashCode()+"[");
    result.append("pixel type:"+getPixelType()+";");
    result.append("width:"+getWidth()+";");
    result.append("height:"+getHeight()+";");
    result.append("time stamp:"+getTimeStamp()+";");
    result.append("complete:"+isComplete()+";");
    result.append("size:"+getSize()+";");
    result.append("key:"+isKey()+";");
    IRational timeBase = IRational.make(1,(int)Global.DEFAULT_PTS_PER_SECOND);
    result.append("time base:"+timeBase+";");
    if (timeBase != null) timeBase.delete();
    result.append("]");
    return result.toString();
  }


  /**
   * Is this a key frame?<br>
   * <br>
   * @return is this a key frame
   */
  public boolean isKeyFrame() {
    return XugglerJNI.IVideoPicture_isKeyFrame(swigCPtr, this);
  }

  /**
   * Reset if this is a key frame or not.  Note that regardless of how<br>
   * this flag is set, an IVideoPicture always contains raw video data (hence the<br>
   * key setting isn't really that important).<br>
   * <br>
   * @param aIsKey True if a key frame; false if not.
   */
  public void setKeyFrame(boolean aIsKey) {
    XugglerJNI.IVideoPicture_setKeyFrame(swigCPtr, this, aIsKey);
  }

  /**
   * Is this picture completely decoded?<br>
   * <br>
   * @return is this picture completely decoded?
   */
  public boolean isComplete() {
    return XugglerJNI.IVideoPicture_isComplete(swigCPtr, this);
  }

  /**
   * Total size in bytes of the decoded picture.<br>
   * <br>
   * @return number of bytes of decoded picture
   */
  public int getSize() {
    return XugglerJNI.IVideoPicture_getSize(swigCPtr, this);
  }

  /**
   * What is the width of the picture.<br>
   * <br>
   * @return the width of the picture
   */
  public int getWidth() {
    return XugglerJNI.IVideoPicture_getWidth(swigCPtr, this);
  }

  /**
   * What is the height of the picture<br>
   * <br>
   * @return the height of the picture
   */
  public int getHeight() {
    return XugglerJNI.IVideoPicture_getHeight(swigCPtr, this);
  }

  /**
   * Returns the pixel format of the picture.<br>
   * <br>
   * @return the pixel format of the picture.
   */
  public IPixelFormat.Type getPixelType() {
    return IPixelFormat.Type.swigToEnum(XugglerJNI.IVideoPicture_getPixelType(swigCPtr, this));
  }

  /**
   * What is the Presentation Time Stamp (in Microseconds) of this picture.<br>
   * <br>
   * The PTS is is scaled so that 1 PTS = <br>
   * 1/1,000,000 of a second.<br>
   * <br>
   * @return the presentation time stamp (pts)
   */
  public long getPts() {
    return XugglerJNI.IVideoPicture_getPts(swigCPtr, this);
  }

  /**
   * Set the Presentation Time Stamp (in Microseconds) for this picture.<br>
   * <br>
   * @see #getPts()<br>
   * <br>
   * @param value the new timestamp
   */
  public void setPts(long value) {
    XugglerJNI.IVideoPicture_setPts(swigCPtr, this, value);
  }

  /**
   * This value is the quality setting this VideoPicture had when it was<br>
   * decoded, or is the value to use when this picture is next<br>
   * encoded (if reset with setQuality()<br>
   * <br>
   * @return The quality.
   */
  public int getQuality() {
    return XugglerJNI.IVideoPicture_getQuality(swigCPtr, this);
  }

  /**
   * Set the Quality to a new value.  This will be used the<br>
   * next time this VideoPicture is encoded by a StreamCoder<br>
   * <br>
   * @param newQuality The new quality.
   */
  public void setQuality(int newQuality) {
    XugglerJNI.IVideoPicture_setQuality(swigCPtr, this, newQuality);
  }

  /**
   * Return the size of each line in the VideoPicture data.  Usually there<br>
   * are no more than 4 lines, but the first line no that returns 0<br>
   * is the end of the road.<br>
   * <br>
   * @param lineNo The line you want to know the (byte) size of.<br>
   * <br>
   * @return The size (in bytes) of that line in data.
   */
  public int getDataLineSize(int lineNo) {
    return XugglerJNI.IVideoPicture_getDataLineSize(swigCPtr, this, lineNo);
  }

  /**
   * After modifying the raw data in this buffer, call this function to<br>
   * let the object know it is now complete.<br>
   * <br>
   * @param aIsComplete Is this VideoPicture complete<br>
   * @param format The pixel format of the data in this picture.  Must match<br>
   *   what the picture was originally constructed with.<br>
   * @param width The width of the data in this picture.  Must match what<br>
   *   the picture was originally constructed with.<br>
   * @param height The height of the data in this picture.  Must match what<br>
   *   the picture was originally constructed with.<br>
   * @param pts The presentation timestamp of the picture that is now complete.<br>
   *   The caller must ensure this PTS is in units of 1/1,000,000 seconds.
   */
  public void setComplete(boolean aIsComplete, IPixelFormat.Type format, int width, int height, long pts) {
    XugglerJNI.IVideoPicture_setComplete(swigCPtr, this, aIsComplete, format.swigValue(), width, height, pts);
  }

  /**
   * Copy the contents of the given picture into this picture.  All<br>
   * buffers are copied by value, not be reference.<br>
   * <br>
   * @param srcPicture The picture you want to copy.<br>
   * <br>
   * @return true if a successful copy; false if not.
   */
  public boolean copy(IVideoPicture srcPicture) {
    return XugglerJNI.IVideoPicture_copy(swigCPtr, this, IVideoPicture.getCPtr(srcPicture), srcPicture);
  }

  /**
   * Render this picture on configured surface. <br>
   * Works only with HW accelerated {com.xuggle.xuggler.IPixelFormat}.<br>
   * {com.xuggle.xuggler.IStreamCoder#setHardwareDecoding(IPixelFormat.Type, Object)} <br>
   * must be called before opening decoder. 
   */
  public void render() {
    XugglerJNI.IVideoPicture_render(swigCPtr, this);
  }

  /**
   * Get a new picture object.<br>
   * <p><br>
   * You can specify -1 for width and height, in which case all getData() methods<br>
   * will return error until XUGGLER decodes something into this frame.  In general<br>
   * you should always try to specify the width and height.<br>
   * </p><br>
   * <p><br>
   * Note that any buffers this objects needs will be<br>
   * lazily allocated (i.e. we won't actually grab all<br>
   * the memory until we need it).<br>
   * </p><br>
   * <p>This is useful because<br>
   * it allows you to hold a IVideoPicture object that remembers<br>
   * things like format, width, and height, but know<br>
   * that it doesn't actually take up a lot of memory until<br>
   * the first time someone tries to access that memory.<br>
   * </p><br>
   * @param format The pixel format (for example, YUV420P).<br>
   * @param width The width of the picture, in pixels, or -1 if you want XUGGLER to guess when decoding.<br>
   * @param height The height of the picture, in pixels, or -1 if you want XUGGLER to guess when decoding.<br>
   * @return A new object, or null if we can't allocate one.
   */
  public static IVideoPicture make(IPixelFormat.Type format, int width, int height) {
    long cPtr = XugglerJNI.IVideoPicture_make__SWIG_0(format.swigValue(), width, height);
    return (cPtr == 0) ? null : new IVideoPicture(cPtr, false);
  }

  /**
   * Get a new picture by copying the data in an existing frame.<br>
   * @param src The picture to copy.<br>
   * @return The new picture, or null on error.
   */
  public static IVideoPicture make(IVideoPicture src) {
    long cPtr = XugglerJNI.IVideoPicture_make__SWIG_1(IVideoPicture.getCPtr(src), src);
    return (cPtr == 0) ? null : new IVideoPicture(cPtr, false);
  }

  /**
   * Get the picture type.<br>
   * <p><br>
   * This will be set on decoding to tell you what type of<br>
   * packet this was decoded from, and when encoding<br>
   * is a request to the encoder for how to encode the picture.<br>
   * </p><br>
   * <p><br>
   * The request may be ignored by your codec.<br>
   * </p><br>
   * @return the picture type.
   */
  public IVideoPicture.PictType getPictureType() {
    return IVideoPicture.PictType.swigToEnum(XugglerJNI.IVideoPicture_getPictureType(swigCPtr, this));
  }

  /**
   * Set the picture type.<br>
   * <br>
   * @param type The type.<br>
   * <br>
   * @see #getPictureType()
   */
  public void setPictureType(IVideoPicture.PictType type) {
    XugglerJNI.IVideoPicture_setPictureType(swigCPtr, this, type.swigValue());
  }

  /**
   * Get a new picture object, by wrapping an existing<br>
   * {com.xuggle.ferry.IBuffer}.<br>
   * <p><br>
   * Use this method if you have existing video data that you want<br>
   * to have us wrap and pass to FFmpeg.  Note that if decoding<br>
   * into this video picture and the decoded data actually takes more<br>
   * space than is in this buffer, this object will release the reference<br>
   * to the passed in buffer and allocate a new buffer instead so the decode<br>
   * can continue.<br>
   * </p><br>
   * <p><br>
   * Due to some decoders assembly optimizations, you should ensure the<br>
   * IBuffer you pass in has at least 8 more bytes than would typically<br>
   * be required based on the format, width and height.<br>
   * </p><br>
   * @param buffer The {com.xuggle.ferry.IBuffer} to wrap.<br>
   * @param format The pixel format (for example, YUV420P).<br>
   * @param width The width of the picture, in pixels.<br>
   * @param height The height of the picture, in pixels.<br>
   * @return A new object, or null if we can't allocate one.
   */
  public static IVideoPicture make(IBuffer buffer, IPixelFormat.Type format, int width, int height) {
    long cPtr = XugglerJNI.IVideoPicture_make__SWIG_2(IBuffer.getCPtr(buffer), buffer, format.swigValue(), width, height);
    return (cPtr == 0) ? null : new IVideoPicture(cPtr, false);
  }

  /**
   * The different types of images that we can set. <br>
   * <br>
   * @see #getPictureType()
   */
  public enum PictType {
    DEFAULT_TYPE(XugglerJNI.IVideoPicture_DEFAULT_TYPE_get()),
    I_TYPE(XugglerJNI.IVideoPicture_I_TYPE_get()),
    P_TYPE(XugglerJNI.IVideoPicture_P_TYPE_get()),
    B_TYPE(XugglerJNI.IVideoPicture_B_TYPE_get()),
    S_TYPE(XugglerJNI.IVideoPicture_S_TYPE_get()),
    SI_TYPE(XugglerJNI.IVideoPicture_SI_TYPE_get()),
    SP_TYPE(XugglerJNI.IVideoPicture_SP_TYPE_get()),
    BI_TYPE(XugglerJNI.IVideoPicture_BI_TYPE_get());

    public final int swigValue() {
      return swigValue;
    }

    public static PictType swigToEnum(int swigValue) {
      PictType[] swigValues = PictType.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (PictType swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + PictType.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private PictType() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private PictType(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private PictType(PictType swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

}
