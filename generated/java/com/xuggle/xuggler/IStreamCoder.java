/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.xuggle.xuggler;
import com.xuggle.ferry.*;
/**
 * The work horse of the Xuggler: Takes {IPacket} data from an {IContainer}<br>
 * (representing an {IStream}) and an {ICodec} and allows you to decode or encode<br>
 * that data.
 */
public class IStreamCoder extends RefCounted implements com.xuggle.xuggler.IConfigurable {
  private transient long swigCPtr;

  protected IStreamCoder(long cPtr, boolean cMemoryOwn) {
    super(XugglerJNI.IStreamCoder_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected static long getCPtr(IStreamCoder obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        throw new UnsupportedOperationException("C++ destructor does not have public access");
      }
      swigCPtr = 0;
    }
    super.delete();
  }


  /**
   * Returns the fourcc tag, in order of least significant byte
   * to most significant byte.
   *
   * @return a 4 char array of the fourcc
   */
  
  public char[] getCodecTagArray()
  {
    char[] retval = new char[4];
    int fourcc = this.getCodecTag();
    
    retval[0] = (char)(fourcc & 0xFF);
    retval[1] = (char)((fourcc >> 8) & 0xFF);
    retval[2] = (char)((fourcc >> 16) & 0xFF);
    retval[3] = (char)((fourcc >> 24) & 0xFF);
    return retval;
  }
  /**
   * Set the fourcc tag.
   *
   * @param fourcc A four char array, in order of least significant byte
   *  to most significant byte.
   *
   * @throws IllegalArgumentException if the array passed in is not exactly 4 bytes.
   */
   
   public void setCodecTag(char[] fourcc)
   {
     if (fourcc == null || fourcc.length != 4)
      throw new IllegalArgumentException();
     int tag = 0;
     tag = (fourcc[3]<<24)+(fourcc[2]<<16)+(fourcc[1]<<8)+fourcc[0];
     this.setCodecTag(tag);
   }
   
   /**
    * Prints  details on this IStreamCoder
    *
    * @return key details for this IStreamCoder
    */
    
  @Override
  public String toString()
  {
    StringBuilder result = new StringBuilder();
    ICodec.Type type = getCodecType();
    
    result.append(this.getClass().getName()+"@"+hashCode()+"[");
    result.append("codec="+getCodec()+";");
    result.append("time base="+getTimeBase()+";");
    result.append("frame rate="+getFrameRate()+";");
    switch(type)
    {
      case CODEC_TYPE_VIDEO:
        result.append("pixel type="+getPixelType()+";");
        result.append("width="+getWidth()+";");
        result.append("height="+getHeight()+";");
        break;
      case CODEC_TYPE_AUDIO:
        result.append("sample rate="+getSampleRate()+";");
        result.append("channels="+getChannels()+";");
        break;
      default:
        break;
    }
    result.append("]");
    return result.toString();
  }
  
  /**
   * {@inheritDoc}
   */
  public java.util.Collection<String> getPropertyNames()
  {
    java.util.Collection<String> retval = new java.util.LinkedList<String>();
    int numProperties = this.getNumProperties();
    for(int i = 0; i < numProperties; i++)
    {
      IProperty property = this.getPropertyMetaData(i);
      String name = property.getName();
      retval.add(name);
    }
    return retval;
  }

  /**
   * Returns <strong>a read-only copy</strong> of the extra data in this stream coder as a new {@link IBuffer}.
   * @return the extra data, or null if none or error.
   * @since 3.3
   */
  public IBuffer getExtraData()
  {
    int size = getExtraDataSize();
    if (size <= 0)
      return null;
    
    IBuffer retval = IBuffer.make(this, size);
    if (retval == null)
      return null;
    if (getExtraData(retval, 0, size) != size) {
      retval.delete();
      retval = null;
    }
    return retval;
  }

  

  /**
   *  Get the direction.<br>
   * @return The direction this StreamCoder works in.
   */
  public IStreamCoder.Direction getDirection() {
    return IStreamCoder.Direction.swigToEnum(XugglerJNI.IStreamCoder_getDirection(swigCPtr, this));
  }

  /**
   * The associated Stream we're working on.<br>
   * <br>
   * @return The stream associated with this object.
   */
  public IStream getStream() {
    long cPtr = XugglerJNI.IStreamCoder_getStream(swigCPtr, this);
    return (cPtr == 0) ? null : new IStream(cPtr, false);
  }

  /**
   * The Codec this StreamCoder will use.<br>
   * <br>
   * @return The Codec used by this StreamCoder, or 0 (null) if none.
   */
  public ICodec getCodec() {
    long cPtr = XugglerJNI.IStreamCoder_getCodec(swigCPtr, this);
    return (cPtr == 0) ? null : new ICodec(cPtr, false);
  }

  /**
   * A short hand for getCodec().getType().<br>
   * <br>
   * <p><br>
   * <b><br>
   * Note for Native (C++) users:<br>
   * </b><br>
   * </p><br>
   * If you actually write code like the above<br>
   * from Native code, you'd leak<br>
   * a Codec() since you didn't call release() on it.<br>
   * This method is a short hand way to avoid you having to<br>
   * worry about releasing in between.<br>
   * <br>
   * @return The Type of the Codec we'll use.
   */
  public ICodec.Type getCodecType() {
    return ICodec.Type.swigToEnum(XugglerJNI.IStreamCoder_getCodecType(swigCPtr, this));
  }

  /**
   * A short hand for getCodec().getID().<br>
   * <br>
   * <p><br>
   * <b><br>
   * Note for Native (C++) users:<br>
   * </b><br>
   * </p><br>
   * If you actually write code like the above<br>
   * from Native code, you'd leak<br>
   * a Codec() since you didn't call release() on it.<br>
   * This method is a short hand way to avoid you having to<br>
   * worry about releasing in between.<br>
   * <br>
   * @return The ID of the Codec we'll use.
   */
  public ICodec.ID getCodecID() {
    return ICodec.ID.swigToEnum(XugglerJNI.IStreamCoder_getCodecID(swigCPtr, this));
  }

  /**
   * Set the Codec to the passed in Codec, discarding the old<br>
   * Codec if set.<br>
   * <p><br>
   * Once you call setCodec, all settings on the IStreamCoder are<br>
   * reset to default values.  So you probably want to call this <br>
   * first.<br>
   * </p><br>
   * <br>
   * @param codec Codec to set.
   */
  public void setCodec(ICodec codec) {
    XugglerJNI.IStreamCoder_setCodec__SWIG_0(swigCPtr, this, ICodec.getCPtr(codec), codec);
  }

  /**
   * Look up a Codec based on the passed in ID, and then set it.<br>
   * <p><br>
   * To see if you actually set the correct ID, call getCodec() and<br>
   * check for 0 (null).<br>
   * </p><br>
   * <p><br>
   * Once you call setCodec, all settings on the IStreamCoder are<br>
   * reset to default values.  So you probably want to call this <br>
   * first.<br>
   * </p><br>
   * <br>
   * @param id ID of codec to set.
   */
  public void setCodec(ICodec.ID id) {
    XugglerJNI.IStreamCoder_setCodec__SWIG_1(swigCPtr, this, id.swigValue());
  }

  /**
   * The bit rate.<br>
   * <br>
   * @return The bit-rate the stream is, or will be, encoded in.
   */
  public int getBitRate() {
    return XugglerJNI.IStreamCoder_getBitRate(swigCPtr, this);
  }

  /**
   * When ENCODING, sets the bit rate to use.  No-op when DECODING.<br>
   * @see #getBitRate()<br>
   * <br>
   * @param rate The bit rate to use.
   */
  public void setBitRate(int rate) {
    XugglerJNI.IStreamCoder_setBitRate(swigCPtr, this, rate);
  }

  /**
   * The bit rate tolerance<br>
   * <br>
   * @return The bit-rate tolerance
   */
  public int getBitRateTolerance() {
    return XugglerJNI.IStreamCoder_getBitRateTolerance(swigCPtr, this);
  }

  /**
   * When ENCODING set the bit rate tolerance.  No-op when DECODING.<br>
   * <br>
   * @param tolerance The bit rate tolerance
   */
  public void setBitRateTolerance(int tolerance) {
    XugglerJNI.IStreamCoder_setBitRateTolerance(swigCPtr, this, tolerance);
  }

  /**
   * The height, in pixels.<br>
   * <br>
   * @return The height of the video frames in the attached stream<br>
   *   or -1 if an audio stream, or we cannot determine the height.
   */
  public int getHeight() {
    return XugglerJNI.IStreamCoder_getHeight(swigCPtr, this);
  }

  /**
   * Set the height, in pixels.<br>
   * <br>
   * @see #getHeight()<br>
   * <br>
   * @param height Sets the height of video frames we'll encode.  No-op when DECODING.
   */
  public void setHeight(int height) {
    XugglerJNI.IStreamCoder_setHeight(swigCPtr, this, height);
  }

  /**
   * The width, in pixels.<br>
   * <br>
   * @return The width of the video frames in the attached stream<br>
   *   or -1 if an audio stream, or we cannot determine the width.
   */
  public int getWidth() {
    return XugglerJNI.IStreamCoder_getWidth(swigCPtr, this);
  }

  /**
   * Set the width, in pixels<br>
   * <br>
   * @see #getWidth()<br>
   * <br>
   * @param width Sets the width of video frames we'll encode.  No-op when DECODING.
   */
  public void setWidth(int width) {
    XugglerJNI.IStreamCoder_setWidth(swigCPtr, this, width);
  }

  /**
   * Get the time base this stream will ENCODE in, or the time base we<br>
   * detect while DECODING.<br>
   * <br>
   * Caller must call release() on the returned value.<br>
   * <br>
   * @return The time base this StreamCoder is using.
   */
  public IRational getTimeBase() {
    long cPtr = XugglerJNI.IStreamCoder_getTimeBase(swigCPtr, this);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

  /**
   * Set the time base we'll use to ENCODE with.  A no-op when DECODING.<br>
   * <br>
   * As a convenience, we forward this call to the Stream#setTimeBase()<br>
   * method.<br>
   * <br>
   * @see #getTimeBase()<br>
   * <br>
   * @param newTimeBase The new time base to use.
   */
  public void setTimeBase(IRational newTimeBase) {
    XugglerJNI.IStreamCoder_setTimeBase(swigCPtr, this, IRational.getCPtr(newTimeBase), newTimeBase);
  }

  /**
   * Get the frame-rate the attached stream claims to be using when<br>
   * DECODING, or the frame-rate we'll claim we're using when ENCODING.<br>
   * <br>
   * @return The frame rate.
   */
  public IRational getFrameRate() {
    long cPtr = XugglerJNI.IStreamCoder_getFrameRate(swigCPtr, this);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

  /**
   * Set the frame rate we'll set in the headers of this stream while<br>
   * ENCODING.  Note that you can set whatever frame-rate you'd like,<br>
   * but the TimeBase and the PTS you set on the encoded audio<br>
   * and video frames can override this.<br>
   * <br>
   * As a convenience, we forward this call to the Stream::setFrameRate()<br>
   * method.<br>
   * <br>
   * @see #getFrameRate()<br>
   * <br>
   * @param newFrameRate The new frame rate to use.
   */
  public void setFrameRate(IRational newFrameRate) {
    XugglerJNI.IStreamCoder_setFrameRate(swigCPtr, this, IRational.getCPtr(newFrameRate), newFrameRate);
  }

  /**
   * The the number of pictures in this Group of Pictures (GOP).  See the<br>
   * MPEG specs for what a GOP is officially, but this is the minimum<br>
   * number of frames between key-frames (or Intra-Frames in MPEG speak).<br>
   * <br>
   * @return the GOPS for this stream.
   */
  public int getNumPicturesInGroupOfPictures() {
    return XugglerJNI.IStreamCoder_getNumPicturesInGroupOfPictures(swigCPtr, this);
  }

  /**
   * Set the GOPS on this stream.  Ignored if DECODING.<br>
   * <br>
   * @see #getNumPicturesInGroupOfPictures()<br>
   * <br>
   * @param gops The new GOPS for the stream we're encoding.
   */
  public void setNumPicturesInGroupOfPictures(int gops) {
    XugglerJNI.IStreamCoder_setNumPicturesInGroupOfPictures(swigCPtr, this, gops);
  }

  /**
   * For Video streams, get the Pixel Format in use by the stream.<br>
   * <br>
   * @return the Pixel format, or IPixelFormat::NONE if audio.
   */
  public IPixelFormat.Type getPixelType() {
    return IPixelFormat.Type.swigToEnum(XugglerJNI.IStreamCoder_getPixelType(swigCPtr, this));
  }

  /**
   * Set the pixel format to ENCODE with.  Ignored if audio or<br>
   * DECODING.<br>
   * <br>
   * @param pixelFmt Pixel format to use.
   */
  public void setPixelType(IPixelFormat.Type pixelFmt) {
    XugglerJNI.IStreamCoder_setPixelType(swigCPtr, this, pixelFmt.swigValue());
  }

  /**
   * Get the sample rate we use for this stream.<br>
   * <br>
   * @return The sample rate (in Hz) we use for this stream, or -1 if unknown or video.
   */
  public int getSampleRate() {
    return XugglerJNI.IStreamCoder_getSampleRate(swigCPtr, this);
  }

  /**
   * Set the sample rate to use when ENCODING.  Ignored if DECODING<br>
   * or a non-audio stream.<br>
   * <br>
   * @param sampleRate New sample rate (in Hz) to use.
   */
  public void setSampleRate(int sampleRate) {
    XugglerJNI.IStreamCoder_setSampleRate(swigCPtr, this, sampleRate);
  }

  /**
   * Get the audio sample format.<br>
   * <br>
   * @return The sample format of samples for encoding/decoding.
   */
  public IAudioSamples.Format getSampleFormat() {
    return IAudioSamples.Format.swigToEnum(XugglerJNI.IStreamCoder_getSampleFormat(swigCPtr, this));
  }

  /**
   * Set the sample format when ENCODING.  Ignored if DECODING<br>
   * or if the coder is already open.<br>
   * <br>
   * @param aFormat The sample format.
   */
  public void setSampleFormat(IAudioSamples.Format aFormat) {
    XugglerJNI.IStreamCoder_setSampleFormat(swigCPtr, this, aFormat.swigValue());
  }

  /**
   * Get the number of channels in this audio stream<br>
   * <br>
   * @return The sample rate (in Hz) we use for this stream, or 0 if unknown.
   */
  public int getChannels() {
    return XugglerJNI.IStreamCoder_getChannels(swigCPtr, this);
  }

  /**
   * Set the number of channels to use when ENCODING.  Ignored if a<br>
   * non audio stream, or if DECODING.<br>
   * <br>
   * @param channels The number of channels we'll encode with.
   */
  public void setChannels(int channels) {
    XugglerJNI.IStreamCoder_setChannels(swigCPtr, this, channels);
  }

  /**
   * For this stream, get the number of audio samples that are<br>
   * represented in a packet of information.<br>
   * <br>
   * @return Number of samples per 'frame' of encoded audio
   */
  public int getAudioFrameSize() {
    return XugglerJNI.IStreamCoder_getAudioFrameSize(swigCPtr, this);
  }

  /**
   * Get the Global Quality setting this codec uses for video if<br>
   * a VideoPicture doesn't have a quality set.<br>
   * <br>
   * @return The global quality.
   */
  public int getGlobalQuality() {
    return XugglerJNI.IStreamCoder_getGlobalQuality(swigCPtr, this);
  }

  /**
   * Set the Global Quality to a new value.<br>
   * <br>
   * @param newQuality The new global quality.
   */
  public void setGlobalQuality(int newQuality) {
    XugglerJNI.IStreamCoder_setGlobalQuality(swigCPtr, this, newQuality);
  }

  /**
   * Get the flags associated with this codec.<br>
   * <br>
   * @return The (compacted) value of all flags set.
   */
  public int getFlags() {
    return XugglerJNI.IStreamCoder_getFlags(swigCPtr, this);
  }

  /**
   * Set the FFMPEG flags to use with this codec.  All values<br>
   * must be ORed (|) together.<br>
   * <br>
   * @see Flags<br>
   * <br>
   * @param newFlags The new set flags for this codec.
   */
  public void setFlags(int newFlags) {
    XugglerJNI.IStreamCoder_setFlags(swigCPtr, this, newFlags);
  }

  /**
   * Get the setting for the specified flag<br>
   * <br>
   * @param flag The flag you want to find the setting for<br>
   * <br>
   * @return 0 for false; non-zero for true
   */
  public boolean getFlag(IStreamCoder.Flags flag) {
    return XugglerJNI.IStreamCoder_getFlag(swigCPtr, this, flag.swigValue());
  }

  /**
   * Set the flag.<br>
   * <br>
   * @param flag The flag to set<br>
   * @param value The value to set it to (true or false)
   */
  public void setFlag(IStreamCoder.Flags flag, boolean value) {
    XugglerJNI.IStreamCoder_setFlag(swigCPtr, this, flag.swigValue(), value);
  }

  /**
   * For this stream, get the next Pts that we expect to decode.<br>
   * <br>
   * Note that this may not actually be the next Pts (for example<br>
   * due to transmission packet drops in the input source).  Still<br>
   * it can be a useful tool.<br>
   * <br>
   * @return The next presentation time stamp we expect to decode<br>
   *   on this stream.  This is always in units of 1/1,000,000 seconds
   */
  public long getNextPredictedPts() {
    return XugglerJNI.IStreamCoder_getNextPredictedPts(swigCPtr, this);
  }

  /**
   * @deprecated Use {#open(IMetaData,IMetaData)} instead.<br>
   * Open the Codec associated with this StreamCoder.<br>
   * <br>
   * You can get the codec through getCodec(...) and<br>
   * set it with setCodec(...).  You cannot call any<br>
   * set* methods after you've called open() on this StreamCoder<br>
   * until you close() it.<br>
   * <br>
   * You must call close() when you're done, but if you don't,<br>
   * the container will clean up after you (but yell at you)<br>
   * when it is closed.<br>
   * <br>
   * @return &gt;= 0 on success; &lt; 0 on error.
   */
  @Deprecated public int open() {
    return XugglerJNI.IStreamCoder_open__SWIG_0(swigCPtr, this);
  }

  /**
   * Close a Codec that was opened on this StreamCoder.<br>
   * <br>
   * @return &gt;= 0 on success; &lt; 0 on error.
   */
  public int close() {
    return XugglerJNI.IStreamCoder_close(swigCPtr, this);
  }

  /**
   * Decode this packet into pOutSamples.  It will<br>
   * try to fill up the audio samples object, starting<br>
   * from the byteOffset inside this packet.<br>
   * <p><br>
   * The caller is responsible for allocating the<br>
   * IAudioSamples object.  This function will overwrite<br>
   * any data in the samples object.<br>
   * </p><br>
   * <p><br>
   * Note that the IAudioSamples object passed in must have<br>
   * a {IAudioSamples#getMaxBufferSize()} of at least<br>
   * 192kbytes.  Sorry, but this requirement is imposed<br>
   * on us via FFmpeg.  If the buffer is not large enough,<br>
   * this method will reallocate the underlying buffers to<br>
   * make them at least 192kbytes.<br>
   * </p><br>
   * @param pOutSamples The AudioSamples we decode to<br>
   * @param packet    The packet we're attempting to decode from.<br>
   * @param byteOffset Where in the packet payload to start decoding<br>
   * <br>
   * @return number of bytes actually processed from the packet, or negative for error
   */
  public int decodeAudio(IAudioSamples pOutSamples, IPacket packet, int byteOffset) {
    return XugglerJNI.IStreamCoder_decodeAudio(swigCPtr, this, IAudioSamples.getCPtr(pOutSamples), pOutSamples, IPacket.getCPtr(packet), packet, byteOffset);
  }

  /**
   * Decode this packet into pOutFrame.<br>
   * <br>
   * The caller is responsible for allocating the<br>
   * IVideoPicture object.  This function will potentially<br>
   * overwrite any data in the frame object, but<br>
   * you should pass the same IVideoPicture into this function<br>
   * repeatedly until IVideoPicture::isComplete() is true.<br>
   * <br>
   * @param pOutFrame The AudioSamples we decode.<br>
   * @param packet    The packet we're attempting to decode from.<br>
   * @param byteOffset Where in the packet payload to start decoding<br>
   * <br>
   * @return number of bytes actually processed from the packet, or negative for error
   */
  public int decodeVideo(IVideoPicture pOutFrame, IPacket packet, int byteOffset) {
    return XugglerJNI.IStreamCoder_decodeVideo(swigCPtr, this, IVideoPicture.getCPtr(pOutFrame), pOutFrame, IPacket.getCPtr(packet), packet, byteOffset);
  }

  /**
   * Encode the given frame using this StreamCoder.<br>
   * <br>
   * The VideoPicture will allocate a buffer to use internally for this, and<br>
   * will free it when the frame destroys itself.<br>
   * <br>
   * Also, when done in order to flush the encoder, caller should call<br>
   * this method passing in 0 (null) for pFrame to tell the encoder<br>
   * to flush any data it was keeping a hold of.<br>
   * <br>
   * @param pOutPacket [out] The packet to encode into.  It will point<br>
   *     to a buffer allocated in the frame.  Caller should check IPacket::isComplete()<br>
   *     after call to find out if we had enough information to encode a full packet.<br>
   * @param pFrame [in/out] The frame to encode<br>
   * @param suggestedBufferSize The suggested buffer size to allocate or -1 for choose ourselves.<br>
   *        If -1 we'll allocate a buffer exactly the same size (+1) as the decoded frame<br>
   *        with the guess that you're encoding a frame because you want to use LESS space<br>
   *        than that.<br>
   * <br>
   * @ return &gt;= 0 on success; &lt;0 on error.
   */
  public int encodeVideo(IPacket pOutPacket, IVideoPicture pFrame, int suggestedBufferSize) {
    return XugglerJNI.IStreamCoder_encodeVideo(swigCPtr, this, IPacket.getCPtr(pOutPacket), pOutPacket, IVideoPicture.getCPtr(pFrame), pFrame, suggestedBufferSize);
  }

  /**
   * Encode the given samples using this StreamCoder.<br>
   * <br>
   * The VideoPicture will allocate a buffer to use internally for this, and<br>
   * will free it when the frame destroys itself.<br>
   * <br>
   * Callers should call this repeatedly on a set of samples until<br>
   * we consume all the samples.<br>
   * <br>
   * Also, when done in order to flush the encoder, caller should call<br>
   * this method passing in 0 (null) for pSamples to tell the encoder<br>
   * to flush any data it was keeping a hold of.<br>
   * <br>
   * @param pOutPacket [out] The packet to encode into.  It will point<br>
   *          to a buffer allocated in the frame.  Caller should check IPacket::isComplete()<br>
   *     after call to find out if we had enough information to encode a full packet.<br>
   * @param pSamples [in] The samples to consume<br>
   * @param sampleToStartFrom [in] Which sample you want to start with<br>
   *          This is usually zero, but if you're using a codec that<br>
   *          packetizes output with small number of samples, you may<br>
   *          need to call encodeAudio repeatedly with different starting<br>
   *          samples to consume all of your samples.<br>
   * <br>
   * @return number of samples we consumed when encoding, or negative for errors.
   */
  public int encodeAudio(IPacket pOutPacket, IAudioSamples pSamples, long sampleToStartFrom) {
    return XugglerJNI.IStreamCoder_encodeAudio(swigCPtr, this, IPacket.getCPtr(pOutPacket), pOutPacket, IAudioSamples.getCPtr(pSamples), pSamples, sampleToStartFrom);
  }

  /**
   * @deprecated Use {#make(Direction, ICodec)} instead.<br>
   * Create a standalone StreamCoder that can decode data without regard to<br>
   * which IStream or IContainer it came from.<br>
   * <p><br>
   * If you're reading or writing to a XUGGLER file or URL you almost definitely<br>
   * don't want to use this method.  Use the {IContainer#getStream(long)}<br>
   * and {IStream#getStreamCoder()} methods instead as it will set up the<br>
   * resulting IStreamCoder with sensible defaults.  Use of a un-attached<br>
   * StreamCoder returned from this method is for advanced users only.<br>
   * </p><br>
   * @param direction The direction this StreamCoder will work in.<br>
   * @return a new stream coder, or null if error.
   */
  @Deprecated public static IStreamCoder make(IStreamCoder.Direction direction) {
    long cPtr = XugglerJNI.IStreamCoder_make__SWIG_0(direction.swigValue());
    return (cPtr == 0) ? null : new IStreamCoder(cPtr, false);
  }

  /**
   * Returns the 4-byte FOURCC tag (Least Significant Byte first).<br>
   * <br>
   * This is really a packed 4-byte array so it's only useful if you use<br>
   * bit-wise operations on it.  Some language wrappings may provide more<br>
   * obvious ways of manipulating, but this is the safest way to do this that<br>
   * will work with all wrappers.<br>
   * <br>
   * @return the FOURCC tag.
   */
  public int getCodecTag() {
    return XugglerJNI.IStreamCoder_getCodecTag(swigCPtr, this);
  }

  /**
   * Set the 4-byte FOURCC tag for this coder.<br>
   * @param fourcc The FOURCC to set, with Least Significant Byte first.
   */
  public void setCodecTag(int fourcc) {
    XugglerJNI.IStreamCoder_setCodecTag(swigCPtr, this, fourcc);
  }

  /**
   * Returns the total number of settable properties on this object<br>
   * <br>
   * @return total number of options (not including constant definitions)
   */
  public int getNumProperties() {
    return XugglerJNI.IStreamCoder_getNumProperties(swigCPtr, this);
  }

  /**
   * Returns the name of the numbered property.<br>
   * <br>
   * @param propertyNo The property number in the options list.<br>
   * <br>
   * @return an IProperty value for this properties meta-data
   */
  public IProperty getPropertyMetaData(int propertyNo) {
    long cPtr = XugglerJNI.IStreamCoder_getPropertyMetaData__SWIG_0(swigCPtr, this, propertyNo);
    return (cPtr == 0) ? null : new IProperty(cPtr, false);
  }

  /**
   * Returns the name of the numbered property.<br>
   * <br>
   * @param name  The property name.<br>
   * <br>
   * @return an IProperty value for this properties meta-data
   */
  public IProperty getPropertyMetaData(String name) {
    long cPtr = XugglerJNI.IStreamCoder_getPropertyMetaData__SWIG_1(swigCPtr, this, name);
    return (cPtr == 0) ? null : new IProperty(cPtr, false);
  }

  /**
   * Sets a property on this Object.<br>
   * <br>
   * All AVOptions supported by the underlying AVClass are supported.<br>
   * <br>
   * @param name The property name.  For example "b" for bit-rate.<br>
   * @param value The value of the property. <br>
   * <br>
   * @return &gt;= 0 if the property was successfully set; &lt;0 on error
   */
  public int setProperty(String name, String value) {
    return XugglerJNI.IStreamCoder_setProperty__SWIG_0(swigCPtr, this, name, value);
  }

  /**
   * Looks up the property 'name' and sets the<br>
   * value of the property to 'value'.<br>
   * <br>
   * @param name name of option<br>
   * @param value Value of option<br>
   * <br>
   * @return &gt;= 0 on success; &lt;0 on error.
   */
  public int setProperty(String name, double value) {
    return XugglerJNI.IStreamCoder_setProperty__SWIG_1(swigCPtr, this, name, value);
  }

  /**
   * Looks up the property 'name' and sets the<br>
   * value of the property to 'value'.<br>
   * <br>
   * @param name name of option<br>
   * @param value Value of option<br>
   * <br>
   * @return &gt;= 0 on success; &lt;0 on error.
   */
  public int setProperty(String name, long value) {
    return XugglerJNI.IStreamCoder_setProperty__SWIG_2(swigCPtr, this, name, value);
  }

  /**
   * Looks up the property 'name' and sets the<br>
   * value of the property to 'value'.<br>
   * <br>
   * @param name name of option<br>
   * @param value Value of option<br>
   * <br>
   * @return &gt;= 0 on success; &lt;0 on error.
   */
  public int setProperty(String name, boolean value) {
    return XugglerJNI.IStreamCoder_setProperty__SWIG_3(swigCPtr, this, name, value);
  }

  /**
   * Looks up the property 'name' and sets the<br>
   * value of the property to 'value'.<br>
   * <br>
   * @param name name of option<br>
   * @param value Value of option<br>
   * <br>
   * @return &gt;= 0 on success; &lt;0 on error.
   */
  public int setProperty(String name, IRational value) {
    return XugglerJNI.IStreamCoder_setProperty__SWIG_4(swigCPtr, this, name, IRational.getCPtr(value), value);
  }

  /**
   * Gets a property on this Object.<br>
   * <br>
   * Note for C++ callers; you must free the returned array with<br>
   * delete[] in order to avoid a memory leak.  Other language<br>
   * folks need not worry.<br>
   * <br>
   * @param name property name<br>
   * <br>
   * @return an string copy of the option value, or null if the option doesn't exist.
   */
  public String getPropertyAsString(String name) {
    return XugglerJNI.IStreamCoder_getPropertyAsString(swigCPtr, this, name);
  }

  /**
   * Gets the value of this property, and returns as a double;<br>
   * <br>
   * @param name name of option<br>
   * <br>
   * @return double value of property, or 0 on error.
   */
  public double getPropertyAsDouble(String name) {
    return XugglerJNI.IStreamCoder_getPropertyAsDouble(swigCPtr, this, name);
  }

  /**
   * Gets the value of this property, and returns as an long;<br>
   * <br>
   * @param name name of option<br>
   * <br>
   * @return long value of property, or 0 on error.
   */
  public long getPropertyAsLong(String name) {
    return XugglerJNI.IStreamCoder_getPropertyAsLong(swigCPtr, this, name);
  }

  /**
   * Gets the value of this property, and returns as an IRational;<br>
   * <br>
   * @param name name of option<br>
   * <br>
   * @return long value of property, or 0 on error.
   */
  public IRational getPropertyAsRational(String name) {
    long cPtr = XugglerJNI.IStreamCoder_getPropertyAsRational(swigCPtr, this, name);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

  /**
   * Gets the value of this property, and returns as a boolean<br>
   * <br>
   * @param name name of option<br>
   * <br>
   * @return boolean value of property, or false on error.
   */
  public boolean getPropertyAsBoolean(String name) {
    return XugglerJNI.IStreamCoder_getPropertyAsBoolean(swigCPtr, this, name);
  }

  /**
   * Returns true if this IStreamCoder is currently open.<br>
   * <br>
   * @return true if open; false if not
   */
  public boolean isOpen() {
    return XugglerJNI.IStreamCoder_isOpen(swigCPtr, this);
  }

  /**
   * Get the default audio frame size (in samples).<br>
   * <br>
   * Some codecs, especially raw codecs, like PCM, don't have<br>
   * a standard frame size.  In those cases, we use the value<br>
   * of this setting to determine how many samples to encode into<br>
   * a single packet.<br>
   * <br>
   * @return the number of samples in an audio frame size if the codec<br>
   *   doesn't specify the size.<br>
   * @since 1.21
   */
  public int getDefaultAudioFrameSize() {
    return XugglerJNI.IStreamCoder_getDefaultAudioFrameSize(swigCPtr, this);
  }

  /**
   * Set the default audio frame size.<br>
   * <br>
   * @param aNewSize The new number of samples to use to encode<br>
   *   samples into a packet.  This setting is ignored if &lt;= 0<br>
   *   or if the codec requires it's own frame size (e.g. Nellymoser).<br>
   * <br>
   * @see #getDefaultAudioFrameSize()<br>
   * @since 1.21
   */
  public void setDefaultAudioFrameSize(int aNewSize) {
    XugglerJNI.IStreamCoder_setDefaultAudioFrameSize(swigCPtr, this, aNewSize);
  }

  /**
   * Creates a new IStreamCoder object by copying all the settings in copyCoder.<br>
   * <p><br>
   * The new IStreamCoder is created by copying all the current properties on the<br>
   * passed in StreamCoder.  If the passed in stream coder is in a different direction<br>
   * than the one you want, this method still set the same codec ID, and the<br>
   * IStreamCoder.open() method will check then to see if it can work in the<br>
   * specified direction.<br>
   * </p><br>
   * <p><br>
   * For example, imagine that direction is ENCODING and the copyCoder is a DECODING StreamCoder that is<br>
   * of the CODEC_ID_VP6 type.  The resulting new IStreamCoder has it's code set to CODEC_ID_VP6.  However<br>
   * (as of the writing of this comment) we don't support encoding to CODEC_ID_VP6, so when you<br>
   * try to open the codec we will fail.<br>
   * </p>  <br>
   * @param direction The direction you want the new IStreamCoder to work in.<br>
   * @param copyCoder The coder to copy settings from.<br>
   * <br>
   * @return A new IStreamCoder, or null on error.<br>
   * @since 1.22
   */
  public static IStreamCoder make(IStreamCoder.Direction direction, IStreamCoder copyCoder) {
    long cPtr = XugglerJNI.IStreamCoder_make__SWIG_1(direction.swigValue(), IStreamCoder.getCPtr(copyCoder), copyCoder);
    return (cPtr == 0) ? null : new IStreamCoder(cPtr, false);
  }

  /**
   * Get the number of frames this StreamCoder had to drop to<br>
   * encode at the specified {#getTimeBase()}<br>
   * <p><br>
   * IStreamCoder objects can encode audio and video, but<br>
   * guarantee that every packet outputted has monotonically<br>
   * increasing timestamps (i.e. 0, 1, 2, 3, 4, 5, etc. without<br>
   * repeats).  Sometimes data is passed too quickly into an<br>
   * IStreamCoder via {#encodeVideo} or {#encodeAudio},<br>
   * and the underlying codec can't handle it that quickly.  In those<br>
   * cases the IStreamCoder must drop the most recent frame of data.<br>
   * </p><br>
   * <p><br>
   * If you're seeing a lot of dropped frames you can try either<br>
   * sending less frequent data to the IStreamCoder, or adjusting<br>
   * the {#getTimeBase()} to the highest possible resolution.<br>
   * Be warned though; some codecs (such as MPEG2) require fixed<br>
   * time-bases (like 1/25) and so setting a higher resolution<br>
   * time base might end up with the codec not able to encode<br>
   * any data.<br>
   * </p><br>
   * @return the number of frames dropped.<br>
   * @since 3.1
   */
  public long getNumDroppedFrames() {
    return XugglerJNI.IStreamCoder_getNumDroppedFrames(swigCPtr, this);
  }

  /**
   * Should the {IStreamCoder} automatically adjust<br>
   * time stamps on output packets for the {IStream}<br>
   * it is ultimately destined for.<br>
   * <br>
   * <p><br>
   * <br>
   * If this {IStreamCoder} does not know which {IStream}<br>
   * it is destined for, or this {IStreamCoder} isn't used<br>
   * with an {IStream} at all, then this setting is ignored.<br>
   * <br>
   * </p><br>
   * <br>
   * @param value true to automatically adjust.<br>
   * @since 3.2
   */
  public void setAutomaticallyStampPacketsForStream(boolean value) {
    XugglerJNI.IStreamCoder_setAutomaticallyStampPacketsForStream(swigCPtr, this, value);
  }

  /**
   * Does this {IStreamCoder} automatically adjust<br>
   * time stamps on output packets for the {IStream} it<br>
   * is ultimately destined for.<br>
   * @return true for yes; false for no<br>
   * @see #setAutomaticallyStampPacketsForStream(boolean)<br>
   * @since 3.2
   */
  public boolean getAutomaticallyStampPacketsForStream() {
    return XugglerJNI.IStreamCoder_getAutomaticallyStampPacketsForStream(swigCPtr, this);
  }

  /**
   * Look up a Codec based on the passed in ID, and then set it.<br>
   * <p><br>
   * Forwards to {#setCodecID(com.xuggle.xuggler.ICodec.ID)}  <br>
   * </p><br>
   * <p><br>
   * To see if you actually set the correct ID, call getCodec() and<br>
   * check for 0 (null).<br>
   * </p><br>
   * <p><br>
   * Once you call setCodec, all settings on the IStreamCoder are<br>
   * reset to default values.  So you probably want to call this <br>
   * first.<br>
   * </p><br>
   * <br>
   * @param id ID of codec to set.<br>
   * @since 3.2
   */
  public void setCodecID(ICodec.ID id) {
    XugglerJNI.IStreamCoder_setCodecID(swigCPtr, this, id.swigValue());
  }

  /**
   * Copies data from the given buffer into the extra-data area maintained<br>
   * by encoders.<br>
   * <p><br>
   * This is an extremely advanced method, and incorrect usage can result<br>
   * in Java crashes so take care.  In general people should not need to use this.<br>
   * </p><br>
   * <p><br>
   * For some codecs (e.g. for H264, this is global header information and<br>
   * for rv10 it is additional flags),<br>
   *  Xuggler maintains extra information about<br>
   * the codec in a extra data buffer.  In general Xuggler will allocate this<br>
   * data as needed and you never need to set it (or get it).  But if you know what you're<br>
   * doing, you can ask Xuggler to replace the existing extra data for the<br>
   * given codec with a copy of the data in the given buffer.<br>
   * </p><br>
   * <p><br>
   * You should call this method after you call {#open()} but before<br>
   * you encode or decode any media.<br>
   * </p><br>
   * @param src The data to copy<br>
   * @param offset The position, in bytes, to start copying data from src<br>
   * @param length The number of bytes to copy from data<br>
   * @param allocNew If true, and there is not enough space in the existing<br>
   *   extra data buffer, then Xuggler will discard the old buffer and allocate a new buffer.<br>
   *   If false, then Xuggler will attempt to copy the data into the existing buffer and if there<br>
   *   is not enough space in the existing buffer, no bytes will be copied and an error will<br>
   *   be returned.  In general, you should set this to false if that works for you.<br>
   * @return The number of bytes copied, or &lt; 0 on error.<br>
   * <br>
   * @since 3.3
   */
  public int setExtraData(IBuffer src, int offset, int length, boolean allocNew) {
    return XugglerJNI.IStreamCoder_setExtraData(swigCPtr, this, IBuffer.getCPtr(src), src, offset, length, allocNew);
  }

  /**
   * Copies the current content of the extra-data buffer maintained by this codec (e.g. header bytes)<br>
   * into the dest buffer.<br>
   * <br>
   * @param dest The buffer to copy to.<br>
   * @param offset The position, in bytes, to start writing data to in dest.<br>
   * @param maxBytesToCopy The maximum number of bytes to copy.<br>
   * @return The number of bytes copied, or &lt; 0 on error.<br>
   * <br>
   * @since 3.3
   */
  public int getExtraData(IBuffer dest, int offset, int maxBytesToCopy) {
    return XugglerJNI.IStreamCoder_getExtraData(swigCPtr, this, IBuffer.getCPtr(dest), dest, offset, maxBytesToCopy);
  }

  /**
   * Gets the current number of bytes of data maintained in the coder extra-data area.<br>
   * @return The number of bytes.  If 0, then no data is currently available.<br>
   * <br>
   * @since 3.3
   */
  public int getExtraDataSize() {
    return XugglerJNI.IStreamCoder_getExtraDataSize(swigCPtr, this);
  }

  /**
   * Gets the current level of standards compliance.<br>
   * @return The level of standards compliance.<br>
   * @see CodecStandardsCompliance<br>
   * @since 5.0
   */
  public IStreamCoder.CodecStandardsCompliance getStandardsCompliance() {
    return IStreamCoder.CodecStandardsCompliance.swigToEnum(XugglerJNI.IStreamCoder_getStandardsCompliance(swigCPtr, this));
  }

  /**
   * Set the level of standards compliance.  Only paid attention to<br>
   * before the code is opened.<br>
   * <br>
   * @param compliance The desired compliance level to set<br>
   * @return 0 on success; non-zero on failure<br>
   * @see CodecStandardsCompliance<br>
   * @since 5.0
   */
  public int setStandardsCompliance(IStreamCoder.CodecStandardsCompliance compliance) {
    return XugglerJNI.IStreamCoder_setStandardsCompliance(swigCPtr, this, compliance.swigValue());
  }

  /**
   * Try to change current decoder to an HW decoder compatible with<br>
   * pixel format<br>
   * <br>
   * @param type an HW accelerated pixel format<br>
   * @return 0 on success; non-zero on failure
   */
  public int setHardwareDecoding(IPixelFormat.Type type, java.lang.Object surface) {
    return XugglerJNI.IStreamCoder_setHardwareDecoding__SWIG_0(swigCPtr, this, type.swigValue(), surface);
  }

  /**
   * Try to change current decoder to an HW decoder compatible with<br>
   * pixel format<br>
   * <br>
   * @param type an HW accelerated pixel format<br>
   * @return 0 on success; non-zero on failure
   */
  public int setHardwareDecoding(IPixelFormat.Type type) {
    return XugglerJNI.IStreamCoder_setHardwareDecoding__SWIG_1(swigCPtr, this, type.swigValue());
  }

  /**
   * Open the codec with the given options.<br>
   * <br>
   * Callers must call {#setCodec} before calling this method.<br>
   * <br>
   * @param options If non-NULL, a dictionary of parameter options to set for this codec.<br>
   * @param unsetOptions If non-NULL, on successful return the prior contents of this set<br>
   *   of meta data will be replaced with any settings in 'options' that could not be set<br>
   *   on this codec.<br>
   * <br>
   * @return 0 on success; &lt;0 on error<br>
   * <br>
   * @since 5.0
   */
  public int open(IMetaData options, IMetaData unsetOptions) {
    return XugglerJNI.IStreamCoder_open__SWIG_1(swigCPtr, this, IMetaData.getCPtr(options), options, IMetaData.getCPtr(unsetOptions), unsetOptions);
  }

  /**
   * Create a standalone StreamCoder that can encode or decode data independent<br>
   * of the stream it is attached to.<br>
   * <br>
   * <p><br>
   * If you're reading or writing to a XUGGLER file or URL you almost definitely<br>
   * don't want to use this method.  Use the {IContainer#getStream(long)}<br>
   * and {IStream#getStreamCoder()} methods instead as it will set up the<br>
   * resulting IStreamCoder with sensible defaults.  Use of a un-attached<br>
   * StreamCoder returned from this method is for advanced users only.<br>
   * </p><br>
   * @param direction The direction this StreamCoder will work in.<br>
   * @param codec The codec you want to use (in lieu of calling {#setCodec}<br>
   * @return a new stream coder, or null if error.<br>
   * <br>
   * @since 5.0
   */
  public static IStreamCoder make(IStreamCoder.Direction direction, ICodec codec) {
    long cPtr = XugglerJNI.IStreamCoder_make__SWIG_2(direction.swigValue(), ICodec.getCPtr(codec), codec);
    return (cPtr == 0) ? null : new IStreamCoder(cPtr, false);
  }

  /**
   * Create a standalone StreamCoder that can encode or decode data independent<br>
   * of the stream it is attached to.<br>
   * <br>
   * <p><br>
   * If you're reading or writing to a XUGGLER file or URL you almost definitely<br>
   * don't want to use this method.  Use the {IContainer#getStream(long)}<br>
   * and {IStream#getStreamCoder()} methods instead as it will set up the<br>
   * resulting IStreamCoder with sensible defaults.  Use of a un-attached<br>
   * StreamCoder returned from this method is for advanced users only.<br>
   * </p><br>
   * @param direction The direction this StreamCoder will work in.<br>
   * @param id The codec id you want to use (in lieu of calling {#setCodec}<br>
   * @return a new stream coder, or null if error.<br>
   * <br>
   * @since 5.0
   */
  public static IStreamCoder make(IStreamCoder.Direction direction, ICodec.ID id) {
    long cPtr = XugglerJNI.IStreamCoder_make__SWIG_3(direction.swigValue(), id.swigValue());
    return (cPtr == 0) ? null : new IStreamCoder(cPtr, false);
  }

  /**
   * {
   */
  public int setProperty(IMetaData valuesToSet, IMetaData valuesNotFound) {
    return XugglerJNI.IStreamCoder_setProperty__SWIG_5(swigCPtr, this, IMetaData.getCPtr(valuesToSet), valuesToSet, IMetaData.getCPtr(valuesNotFound), valuesNotFound);
  }

  /**
   * The Direction in which this StreamCoder will work.
   */
  public enum Direction {
    ENCODING,
    DECODING;

    public final int swigValue() {
      return swigValue;
    }

    public static Direction swigToEnum(int swigValue) {
      Direction[] swigValues = Direction.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (Direction swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + Direction.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private Direction() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private Direction(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private Direction(Direction swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  /**
   * XUGGLER Flags that can be passed to the setFlag(Flags, bool) method
   */
  public enum Flags {
    /**
     *  Use fixed qscale.
     */
    FLAG_QSCALE(XugglerJNI.IStreamCoder_FLAG_QSCALE_get()),
    /**
     *  4 MV per MB allowed / advanced prediction for H.263.
     */
    FLAG_4MV(XugglerJNI.IStreamCoder_FLAG_4MV_get()),
    /**
     *  Use qpel MC.
     */
    FLAG_QPEL(XugglerJNI.IStreamCoder_FLAG_QPEL_get()),
    /**
     *  Use GMC.
     */
    FLAG_GMC(XugglerJNI.IStreamCoder_FLAG_GMC_get()),
    FLAG_MV0(XugglerJNI.IStreamCoder_FLAG_MV0_get()),
    /**
     * The parent program guarantees that the input for B-frames containing<br>
     * streams is not written to for at least s-&gt;max_b_frames+1 frames, if<br>
     * this is not set the input will be copied.
     */
    FLAG_INPUT_PRESERVED(XugglerJNI.IStreamCoder_FLAG_INPUT_PRESERVED_get()),
    /**
     *  Use internal 2pass ratecontrol in first pass mode.
     */
    FLAG_PASS1(XugglerJNI.IStreamCoder_FLAG_PASS1_get()),
    /**
     *  Use internal 2pass ratecontrol in second pass mode.
     */
    FLAG_PASS2(XugglerJNI.IStreamCoder_FLAG_PASS2_get()),
    /**
     *  Only decode/encode grayscale.
     */
    FLAG_GRAY(XugglerJNI.IStreamCoder_FLAG_GRAY_get()),
    /**
     *  Don't draw edges.
     */
    FLAG_EMU_EDGE(XugglerJNI.IStreamCoder_FLAG_EMU_EDGE_get()),
    /**
     *  error[?] variables will be set during encoding.
     */
    FLAG_PSNR(XugglerJNI.IStreamCoder_FLAG_PSNR_get()),
    FLAG_TRUNCATED(XugglerJNI.IStreamCoder_FLAG_TRUNCATED_get()),
    /**
     *  Input bitstream might be truncated at a random<br>
     *                                                   location instead of only at frame boundaries.  Normalize adaptive quantization.
     */
    FLAG_NORMALIZE_AQP(XugglerJNI.IStreamCoder_FLAG_NORMALIZE_AQP_get()),
    /**
     *  Use interlaced DCT.
     */
    FLAG_INTERLACED_DCT(XugglerJNI.IStreamCoder_FLAG_INTERLACED_DCT_get()),
    /**
     *  Force low delay.
     */
    FLAG_LOW_DELAY(XugglerJNI.IStreamCoder_FLAG_LOW_DELAY_get()),
    /**
     *  Place global headers in extradata instead of every keyframe.
     */
    FLAG_GLOBAL_HEADER(XugglerJNI.IStreamCoder_FLAG_GLOBAL_HEADER_get()),
    /**
     *  Use only bitexact stuff (except (I)DCT).
     */
    FLAG_BITEXACT(XugglerJNI.IStreamCoder_FLAG_BITEXACT_get()),
    /**
     *  H.263 advanced intra coding / MPEG-4 AC prediction
     */
    FLAG_AC_PRED(XugglerJNI.IStreamCoder_FLAG_AC_PRED_get()),
    /**
     *  Use rate distortion optimization for cbp.
     */
    FLAG_CBP_RD(XugglerJNI.IStreamCoder_FLAG_CBP_RD_get()),
    /**
     *  Use rate distortion optimization for qp selectioon.
     */
    FLAG_QP_RD(XugglerJNI.IStreamCoder_FLAG_QP_RD_get()),
    /**
     *  loop filter
     */
    FLAG_LOOP_FILTER(XugglerJNI.IStreamCoder_FLAG_LOOP_FILTER_get()),
    /**
     *  interlaced motion estimation
     */
    FLAG_INTERLACED_ME(XugglerJNI.IStreamCoder_FLAG_INTERLACED_ME_get()),
    FLAG_CLOSED_GOP(XugglerJNI.IStreamCoder_FLAG_CLOSED_GOP_get()),
    /**
     *  Allow non spec compliant speedup tricks.
     */
    FLAG2_FAST(XugglerJNI.IStreamCoder_FLAG2_FAST_get()),
    /**
     *  Strictly enforce GOP size.
     */
    FLAG2_STRICT_GOP(XugglerJNI.IStreamCoder_FLAG2_STRICT_GOP_get()),
    /**
     *  Skip bitstream encoding.
     */
    FLAG2_NO_OUTPUT(XugglerJNI.IStreamCoder_FLAG2_NO_OUTPUT_get()),
    /**
     *  Place global headers at every keyframe instead of in extradata.
     */
    FLAG2_LOCAL_HEADER(XugglerJNI.IStreamCoder_FLAG2_LOCAL_HEADER_get()),
    /**
     *  RD optimal MB level residual skipping
     */
    FLAG2_SKIP_RD(XugglerJNI.IStreamCoder_FLAG2_SKIP_RD_get()),
    /**
     *  Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
     */
    FLAG2_CHUNKS(XugglerJNI.IStreamCoder_FLAG2_CHUNKS_get()),
    /**
     *  Show all frames before the first keyframe
     */
    FLAG2_SHOW_ALL(XugglerJNI.IStreamCoder_FLAG2_SHOW_ALL_get());

    public final int swigValue() {
      return swigValue;
    }

    public static Flags swigToEnum(int swigValue) {
      Flags[] swigValues = Flags.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (Flags swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + Flags.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private Flags() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private Flags(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private Flags(Flags swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  /**
   * An enumeration of how strictly Codecs may follow the spec.<br>
   * Not all settings follow these requirements, but some<br>
   * experimental codecs require this flag to be set to use.<br>
   * <br>
   * @since 5.0
   */
  public enum CodecStandardsCompliance {
    /**
     * Strictly conform to an older more strict version of the spec or reference software.
     */
    COMPLIANCE_VERY_STRICT(XugglerJNI.IStreamCoder_COMPLIANCE_VERY_STRICT_get()),
    /**
     * Strictly conform to all the things in the spec no matter what consequences
     */
    COMPLIANCE_STRICT(XugglerJNI.IStreamCoder_COMPLIANCE_STRICT_get()),
    /**
     * Take normal liberties with the spec, including taking the spec out to dinner, and<br>
     * making suggestive comments to the spec.
     */
    COMPLIANCE_NORMAL(XugglerJNI.IStreamCoder_COMPLIANCE_NORMAL_get()),
    /**
     * Allow unofficial, but still mostly chaste, extensions to the spec.
     */
    COMPLIANCE_UNOFFICIAL(XugglerJNI.IStreamCoder_COMPLIANCE_UNOFFICIAL_get()),
    /**
     * Allow nonstandardized experimental things. Potentially deviant things.  The<br>
     * type of things spec authors don't like to talk about, but secretly<br>
     * fantasize about.  You know what I mean, MPEG Working Group.
     */
    COMPLIANCE_EXPERIMENTAL(XugglerJNI.IStreamCoder_COMPLIANCE_EXPERIMENTAL_get());

    public final int swigValue() {
      return swigValue;
    }

    public static CodecStandardsCompliance swigToEnum(int swigValue) {
      CodecStandardsCompliance[] swigValues = CodecStandardsCompliance.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (CodecStandardsCompliance swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + CodecStandardsCompliance.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private CodecStandardsCompliance() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private CodecStandardsCompliance(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private CodecStandardsCompliance(CodecStandardsCompliance swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

}
